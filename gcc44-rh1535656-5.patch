commit 50ef5f99bd63808b2810981d7c64c606ea05d3fc
Author: hjl <hjl@138bc75d-0d04-0410-961f-82ee72b054a4>
Date:   Tue Jan 16 11:19:51 2018 +0000

    HJ patch #4

diff --git a/gcc/config/i386/i386.c b/gcc/config/i386/i386.c
index 9277ba9..c682b32 100644
--- a/gcc/config/i386/i386.c
+++ b/gcc/config/i386/i386.c
@@ -12042,6 +12042,7 @@ put_condition_code (enum rtx_code code, enum machine_mode mode, int reverse,
    If CODE is 'h', pretend the reg is the 'high' byte register.
    If CODE is 'y', print "st(0)" instead of "st", if the reg is stack op.
    If CODE is 'd', duplicate the operand for AVX instruction.
+   If CODE is 'V', print naked full integer register wname without %.
  */
 
 void
@@ -12057,7 +12058,7 @@ print_reg (rtx x, int code, FILE *file)
 		  && REGNO (x) != FPSR_REG
 		  && REGNO (x) != FPCR_REG));
 
-  if (ASSEMBLER_DIALECT == ASM_ATT)
+  if (ASSEMBLER_DIALECT == ASM_ATT && code != 'V')
     putc ('%', file);
 
   if (x == pc_rtx)
@@ -12086,6 +12087,14 @@ print_reg (rtx x, int code, FILE *file)
   else
     code = GET_MODE_SIZE (GET_MODE (x));
 
+  if (code == 'V')
+    {
+      if (GENERAL_REGNO_P (REGNO (x)))
+	code = GET_MODE_SIZE (word_mode);
+      else
+	error ("'V' modifier on non-integer register");
+    }
+
   /* Irritatingly, AMD extended registers use different naming convention
      from the normal registers.  */
   if (REX_INT_REG_P (x))
@@ -12234,6 +12243,7 @@ get_some_local_dynamic_name (void)
    & -- print some in-use local-dynamic symbol name.
    H -- print a memory address offset by 8; used for sse high-parts
    Y -- print condition for XOP pcom* instruction.
+   V -- print naked full integer register name without %.
    + -- print a branch hint as 'cs' or 'ds' prefix
    ; -- print a semicolon (after prefixes due to bug in older gas).
  */
@@ -12403,6 +12413,7 @@ print_operand (FILE *file, rtx x, int code)
 	case 'x':
 	case 'X':
 	case 'P':
+	case 'V':
 	  break;
 
 	case 's':
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-register-4.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-register-4.c
new file mode 100644
index 0000000..211f557
--- /dev/null
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-register-4.c
@@ -0,0 +1,13 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mindirect-branch=keep -fno-pic" } */
+
+extern void (*func_p) (void);
+
+void
+foo (void)
+{
+  asm("call __x86_indirect_thunk_%V0" : : "a" (func_p));
+}
+
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_eax" { target ilp32 } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_rax" { target { ! ilp32 } } } } */
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-10.c b/gcc/testsuite/gcc.target/i386/ret-thunk-10.c
index 704efee..669c8c9 100644
--- a/gcc/testsuite/gcc.target/i386/ret-thunk-10.c
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-10.c
@@ -16,5 +16,5 @@ foo (void)
 /* { dg-final { scan-assembler-times {\tpause} 2 } } */
 /* { dg-final { scan-assembler-times {\tlfence} 2 } } */
 /* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?bar" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" }  } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" } } */
 /* { dg-final { scan-assembler "__x86_indirect_thunk:" } } */
